/**
 * 문제 출처: 백준 온라인 져지
 * https://www.acmicpc.net/problem/3184
 * 
 * 시간제한: 1초
 * 메모리제한: 128MB
 * 
 * 문제
 * 미키의 뒷마당에는 특정 수의 양이 있다. 그가 푹 잠든 사이에 배고픈 늑대는 마당에 들어와 양을 공격했다.
 * 마당은 행과 열로 이루어진 직사각형 모양이다. 글자 '.' (점)은 빈 필드를 의미하며, 글자 '#'는 울타리를, 'o'는 양, 'v'는 늑대를 의미한다.
 * 한 칸에서 수평, 수직만으로 이동하며 울타리를 지나지 않고 다른 칸으로 이동할 수 있다면, 두 칸은 같은 영역 안에 속해 있다고 한다. 마당에서 "탈출"할 수 있는 칸은 어떤 영역에도 속하지 않는다고 간주한다.
 * 다행히 우리의 양은 늑대에게 싸움을 걸 수 있고 영역 안의 양의 수가 늑대의 수보다 많다면 이기고, 늑대를 우리에서 쫓아낸다. 그렇지 않다면 늑대가 그 지역 안의 모든 양을 먹는다.
 * 맨 처음 모든 양과 늑대는 마당 안 영역에 존재한다.
 * 아침이 도달했을 때 살아남은 양과 늑대의 수를 출력하는 프로그램을 작성하라.
 * 
 * 입력
 * 첫 줄에는 두 정수 R과 C가 주어지며(3 ≤ R, C ≤ 250), 각 수는 마당의 행과 열의 수를 의미한다.
 * 다음 R개의 줄은 C개의 글자를 가진다. 이들은 마당의 구조(울타리, 양, 늑대의 위치)를 의미한다.
 * 
    6 6
    ...#..
    .##v#.
    #v.#.#
    #.o#.#
    .###.#
    ...###
 * 
 * 출력
 * 하나의 줄에 아침까지 살아있는 양과 늑대의 수를 의미하는 두 정수를 출력한다.
 * 
    0 2
 * 
 * 파싱
 * r = 6, c = 6
 * arr = [
    [ '.', '.', '.', '#', '.', '.' ],
    [ '.', '#', '#', 'v', '#', '.' ],
    [ '#', 'v', '.', '#', '.', '#' ],
    [ '#', '.', 'o', '#', '.', '#' ],
    [ '.', '#', '#', '#', '.', '#' ],
    [ '.', '.', '.', '#', '#', '#' ]
  ]
 * 
 * {{초기 설정}}
 * 상하좌우
 * dx = [1, -1, 0, 0]
 * dy = [0, 0, 1, -1]
 * 
 * 각 영역에 해당하는 양(O), 늑대(V)의 수
 * O = []
 * V = []
 * 
 * 체크리스트
 * checkList = [[0 * r] * c]
 * 
 * 살아있는 전체 양(OT), 늑대(VT)
 * OT = 0, VT = 0
 */

// 파싱
const fs = require("fs");
let [rc, ...arr] = fs.readFileSync("input.txt").toString().trim().split("\n");
let [r, c] = rc.split(" ").map(Number);
arr = arr.map((a) => a.trim().split(""));

// 초기 설정
let dx = [1, -1, 0, 0];
let dy = [0, 0, 1, -1];
let O = [];
let V = [];
let checkList = [];
let OT = 0;
let VT = 0;

// 체크리스트 초기화
for (let i = 0; i < r; i++) {
  checkList.push(new Array(c).fill(0));
}

/**
 * 해당 인덱스가 울타리가 아니고 방문하지 않은 영역일 때
 * 체크리스트에 방문했다고 표시한 뒤
 * 해당 영역의 양과 늑대의 수를 0으로 push해준다.
 * 그리고 DFS를 수행한다.
 */
for (let i = 0; i < r; i++) {
  for (let j = 0; j < c; j++) {
    if (!checkList[i][j] && arr[i][j] != "#") {
      checkList[i][j] = 1;
      O.push(0);
      V.push(0);
      dfs(i, j);
    }
  }
}

/**
 * DFS가 완료된 후
 * 각 영역마다
 * 양의 수가 늑대의 수보다 많은 경우 전체 양의 수에 해당 영역의 양의 수를 더해주고
 * 그렇지 않은 경우 전체 늑대의 수에 해당 영역의 늑대의 수를 더해준다.
 */
for (let i = 0; i < O.length; i++) {
  if (O[i] > V[i]) {
    OT += O[i];
  } else {
    VT += V[i];
  }
}

/** 정답 출력 */
console.log(OT, VT);

/**
 * * DFS 수행
 * 해당 인덱스에 양이 있을 경우 => 해당 영역의 양의 수 추가 (O[O.length-1]++
 * 해당 인덱스에 늑대가 있을 경우 => 해당 영역의 늑대의 수 추가 (V[V.length-1]++
 *
 * 상하좌우의 영역에 대해
 * 범위체크: 0 <= nx < r , 0 <= ny < c
 * 방문여부체크: !checkList[nx][ny]
 * 필드(.), 양(o), 늑대(v)인지 체크: arr[nx][ny] == "o" || arr[nx][ny] == "v" || arr[nx][ny] == "."
 *
 * 위 조건을 모두 만족하면
 * 방문했다고 체크한 뒤
 * DFS 수행
 */
function dfs(x, y) {
  if (arr[x][y] == "o") {
    O[O.length - 1] += 1;
  } else if (arr[x][y] == "v") {
    V[V.length - 1] += 1;
  }

  for (let i = 0; i < 4; i++) {
    let nx = x + dx[i];
    let ny = y + dy[i];

    if (0 <= nx && nx < r && 0 <= ny && ny < c && !checkList[nx][ny]) {
      if (arr[nx][ny] == "o" || arr[nx][ny] == "v" || arr[nx][ny] == ".") {
        checkList[nx][ny] = 1;
        dfs(nx, ny);
      }
    }
  }
}
/**
 * 채점 결과
 * 메모리: 15264KB
 * 시간: 216ms
 * 언어: JS
 */
