/**
 * !문제 출처: 백준 온라인 져지
 * address: https://www.acmicpc.net/problem/3109
 * 
 * ! 문제
 * 유명한 제빵사 김원웅은 빵집을 운영하고 있다. 원웅이의 빵집은 글로벌 재정 위기를 피해가지 못했고, 결국 심각한 재정 위기에 빠졌다.
 * 원웅이는 지출을 줄이고자 여기저기 지출을 살펴보던 중에, 가스비가 제일 크다는 것을 알게되었다. 따라서 원웅이는 근처 빵집의 가스관에 몰래 파이프를 설치해 훔쳐서 사용하기로 했다.
 * 빵집이 있는 곳은 R*C 격자로 표현할 수 있다. 첫째 열은 근처 빵집의 가스관이고, 마지막 열은 원웅이의 빵집이다.
 * 원웅이는 가스관과 빵집을 연결하는 파이프를 설치하려고 한다. 빵집과 가스관 사이에는 건물이 있을 수도 있다. 건물이 있는 경우에는 파이프를 놓을 수 없다.
 * 가스관과 빵집을 연결하는 모든 파이프라인은 첫째 열에서 시작해야 하고, 마지막 열에서 끝나야 한다. 각 칸은 오른쪽, 오른쪽 위 대각선, 오른쪽 아래 대각선으로 연결할 수 있고, 각 칸의 중심끼리 연결하는 것이다.
 * 원웅이는 가스를 되도록 많이 훔치려고 한다. 따라서, 가스관과 빵집을 연결하는 파이프라인을 여러 개 설치할 것이다. 이 경로는 겹칠 수 없고, 서로 접할 수도 없다. 즉, 각 칸을 지나는 파이프는 하나이어야 한다.
 * 원웅이 빵집의 모습이 주어졌을 때, 원웅이가 설치할 수 있는 가스관과 빵집을 연결하는 파이프라인의 최대 개수를 구하는 프로그램을 작성하시오.
 * 
 * ! 입력 & 파싱
 * 첫째 줄에 R과 C가 주어진다. (1 ≤ R ≤ 10,000, 5 ≤ C ≤ 500)
 * 다음 R개 줄에는 빵집 근처의 모습이 주어진다. '.'는 빈 칸이고, 'x'는 건물이다. 처음과 마지막 열은 항상 비어있다.
 * 
    5 5   -> n m (편의상 n, m)
    .xx.. -> arr[0][0] ~ arr[0][m-1]
    ..x..
    .....
    ...x.
    ...x. -> arr[n-1][0] ~ arr[n-1][m-1]
 * 
 * ! 출력
 * 첫째 줄에 원웅이가 놓을 수 있는 파이프라인의 최대 개수를 출력한다.
 * 
    2
 * 
 * ! 초기 설정
 * dx: 행 이동 방향 (dy는 항상 +1이기 때문에 생략)
 * visited: 방문리스트
 * clear: 행 시작 위치의 파이프라인 성공 여부
 * count: 파이프라인 성공 갯수
 */
// @ 파싱
const fs = require("fs");
let [nm, ...arr] = fs.readFileSync("input.txt").toString().trim().split("\n");
const [n, m] = nm.split(" ").map(Number);
arr = arr.map((a) => a.split(""));

// @ 초기 설정
let dx = [-1, 0, 1];
let visited = Array.from({ length: n }, () => new Array(m).fill(0));
let clear = new Array(n).fill(0);
let count = 0;

// @ 각 첫번째 열의 모든 행에서 DFS 수행
for (let i = 0; i < n; i++) {
  dfs(i, i, 0);
}

// @ 정답 출력
console.log(count);

// @ DFS
function dfs(s, x, y) {
  // @ 파이프라인에 성공했을 때
  if (y == m - 1) {
    clear[s] = 1; // * 성공 표시
    count++; // * 갯수 증가
    return; // * 종료
  }

  // @ 3가지 방향에 대하여
  for (let i = 0; i < 3; i++) {
    let nx = x + dx[i];
    let ny = y + 1;

    // @ 범위 체크 + 방문 체크 + 빈칸인지 체크
    if (0 <= nx && nx < n && ny < m && !visited[nx][ny] && arr[nx][ny] == ".") {
      visited[nx][ny] = 1; // * 방문 표시
      dfs(s, nx, ny); // * DFS 수행
      if (clear[s]) break; // * 파이프라인에 성공하면 종료 -> 다음으로 넘어가지 않음
    }
  }
}
/**
 * ? 채점 결과
 * 메모리: 118996KB
 * 시간: 548ms
 * 언어: JS
 */
