/**
 * 문제 출처: 백준 온라인 져지
 * https://www.acmicpc.net/problem/14716
 * 
 * 시간제한: 2초
 * 메모리제한: 256MB
 * 
 * 입력
 * 첫 번째 줄에는 현수막의 크기인 M와 N가 주어진다. (1 ≤ M, N ≤ 250)
 * 두 번째 줄부터 M+1 번째 줄까지 현수막의 정보가 1과 0으로 주어지며, 1과 0을 제외한 입력은 주어지지 않는다.
 * 
    8 19
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
    0 0 0 1 0 0 0 1 0 0 0 1 0 1 1 1 1 1 0
    0 0 1 0 1 0 0 1 1 0 0 1 0 0 0 1 0 0 0
    0 1 0 0 0 1 0 1 0 1 0 1 0 0 0 1 0 0 0
    0 1 1 1 1 1 0 1 0 1 0 1 0 0 0 1 0 0 0
    0 1 0 0 0 1 0 1 0 0 1 1 0 0 0 1 0 0 0
    0 1 0 0 0 1 0 1 0 0 0 1 0 0 0 1 0 0 0
    0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0
 * 
 * 출력
 * 혁진이의 생각대로 프로그램을 구현했을 때, 현수막에서 글자의 개수가 몇 개인지 출력하여라.
 * 
    3
 * 
 * 파싱
 * m = 8, n = 19
 * arr = [
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  [0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 0],
  [0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0],
  [0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0],
  [0, 1, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0],
  [0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0],
  [0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0],
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]
  ]
 *
 * {{초기 설정}}
 * 상하좌우대각선
 * dx = [1, -1, 0, 0, 1, 1, -1, -1]
 * dy = [0, 0, 1, -1, 1, -1, 1, -1] 
 * 
 * 글자수 count = 0
 * 체크리스트 checkList = [[0 * m] * n]
 */
// 파싱
const fs = require("fs");
let [mn, ...arr] = fs.readFileSync("input.txt").toString().trim().split("\n");
const [m, n] = mn.split(" ").map(Number);
arr = arr.map((a) => a.split(" ").map(Number));

// 초기 설정
let dx = [1, -1, 0, 0, 1, 1, -1, -1];
let dy = [0, 0, 1, -1, 1, -1, 1, -1];
let count = 0;
let checkList = Array.from({ length: m }, () => new Array(n).fill(0));

// 글자 시작
for (let i = 0; i < m; i++) {
  for (let j = 0; j < n; j++) {
    if (arr[i][j] && !checkList[i][j]) {
      count++;
      checkList[i][j] = 1;
      dfs(i, j);
    }
  }
}

console.log(count);

// DFS
function dfs(x, y) {
  for (let i = 0; i < 8; i++) {
    let nx = x + dx[i];
    let ny = y + dy[i];

    if (
      0 <= nx &&
      nx < m &&
      0 <= ny &&
      ny < n &&
      !checkList[nx][ny] &&
      arr[nx][ny]
    ) {
      checkList[nx][ny] = 1;
      dfs(nx, ny);
    }
  }
}
/**
 * 채점 결과
 * 메모리: 19200
 * 시간: 268ms
 * 언어: JS
 */
