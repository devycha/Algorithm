// 부서별로 신청한 금액이 들어있는 배열 d와 예산 budget이 매개변수로 주어질 때, 최대 몇 개의 부서에 물품을 지원할 수 있는지 return 하도록 solution 함수를 완성해주세요.

// 제한사항
// d는 부서별로 신청한 금액이 들어있는 배열이며, 길이(전체 부서의 개수)는 1 이상 100 이하입니다.
// d의 각 원소는 부서별로 신청한 금액을 나타내며, 부서별 신청 금액은 1 이상 100,000 이하의 자연수입니다.
// budget은 예산을 나타내며, 1 이상 10,000,000 이하의 자연수입니다.
// 입출력 예
// d	budget	result
// [1,3,2,5,4]	9	3
// [2,2,3,3]	10	4
// 입출력 예 설명
// 입출력 예 #1
// 각 부서에서 [1원, 3원, 2원, 5원, 4원]만큼의 금액을 신청했습니다. 만약에, 1원, 2원, 4원을 신청한 부서의 물품을 구매해주면 예산 9원에서 7원이 소비되어 2원이 남습니다. 항상 정확히 신청한 금액만큼 지원해 줘야 하므로 남은 2원으로 나머지 부서를 지원해 주지 않습니다. 위 방법 외에 3개 부서를 지원해 줄 방법들은 다음과 같습니다.

// 1원, 2원, 3원을 신청한 부서의 물품을 구매해주려면 6원이 필요합니다.
// 1원, 2원, 5원을 신청한 부서의 물품을 구매해주려면 8원이 필요합니다.
// 1원, 3원, 4원을 신청한 부서의 물품을 구매해주려면 8원이 필요합니다.
// 1원, 3원, 5원을 신청한 부서의 물품을 구매해주려면 9원이 필요합니다.
// 3개 부서보다 더 많은 부서의 물품을 구매해 줄 수는 없으므로 최대 3개 부서의 물품을 구매해 줄 수 있습니다.

// 입출력 예 #2
// 모든 부서의 물품을 구매해주면 10원이 됩니다. 따라서 최대 4개 부서의 물품을 구매해 줄 수 있습니다.
// 나의 풀이
function solution(d, budget) {
    var answer = 0;
    let sum = 0;
    let sort_arr = d.sort((a, b) => a - b);
    for (let i = 0; i < d.length; i++) {
        if (sum + sort_arr[i] <= budget) {
            sum += sort_arr[i];
            answer += 1;
        }
    }
    console.log(sort_arr);
    return answer;
}
// 후기: slice한 후에 sort를 했어야 했는데 급한 마음에 sort를 해서 원래 주어진 배열을 
//      망가뜨렸다. 다음부턴 조심해야지.

// 다른 사람의 풀이 해석
function solution(d, budget) {
    return ~(~d.sort((a, b) => a - b).map(v => budget -= v).findIndex(v => v < 0) || ~d.length);
}